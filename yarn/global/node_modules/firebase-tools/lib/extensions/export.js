"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeFiles = exports.displayExportInfo = exports.setSecretParamsToLatest = exports.parameterizeProject = void 0;
const clc = require("cli-color");
const refs = require("./refs");
const config_1 = require("../config");
const planner_1 = require("../deploy/extensions/planner");
const deploymentSummary_1 = require("../deploy/extensions/deploymentSummary");
const logger_1 = require("../logger");
const error_1 = require("../error");
const prompt_1 = require("../prompt");
const secretManager_1 = require("../gcp/secretManager");
const secretsUtils_1 = require("./secretsUtils");
function parameterizeProject(projectId, projectNumber, spec) {
    const newParams = {};
    for (const [key, val] of Object.entries(spec.params)) {
        const p1 = val.replace(projectId, "${param:PROJECT_ID}");
        const p2 = p1.replace(projectNumber, "${param:PROJECT_NUMBER}");
        newParams[key] = p2;
    }
    const newSpec = Object.assign({}, spec);
    newSpec.params = newParams;
    return newSpec;
}
exports.parameterizeProject = parameterizeProject;
async function setSecretParamsToLatest(spec) {
    const newParams = Object.assign({}, spec.params);
    const extensionVersion = await planner_1.getExtensionVersion(spec);
    const activeSecrets = secretsUtils_1.getActiveSecrets(extensionVersion.spec, newParams);
    for (const [key, val] of Object.entries(newParams)) {
        if (activeSecrets.includes(val)) {
            const parsed = secretManager_1.parseSecretVersionResourceName(val);
            parsed.versionId = "latest";
            newParams[key] = secretManager_1.toSecretVersionResourceName(parsed);
        }
    }
    return Object.assign(Object.assign({}, spec), { params: newParams });
}
exports.setSecretParamsToLatest = setSecretParamsToLatest;
function displayExportInfo(withRef, withoutRef) {
    logger_1.logger.info("The following Extension instances will be saved locally:");
    logger_1.logger.info("");
    displaySpecs(withRef);
    if (withoutRef.length) {
        logger_1.logger.info(`Your project also has the following instances installed from local sources. These will not be saved to firebase.json:`);
        for (const spec of withoutRef) {
            logger_1.logger.info(spec.instanceId);
        }
    }
}
exports.displayExportInfo = displayExportInfo;
function displaySpecs(specs) {
    for (let i = 0; i < specs.length; i++) {
        const spec = specs[i];
        logger_1.logger.info(`${i + 1}. ${deploymentSummary_1.humanReadable(spec)}`);
        logger_1.logger.info(`Configuration will be written to 'extensions/${spec.instanceId}.env'`);
        for (const p of Object.entries(spec.params)) {
            logger_1.logger.info(`\t${p[0]}=${p[1]}`);
        }
        logger_1.logger.info("");
    }
}
function writeExtensionsToFirebaseJson(have, existingConfig) {
    const extensions = existingConfig.get("extensions", {});
    for (const s of have) {
        extensions[s.instanceId] = refs.toExtensionVersionRef(s.ref);
    }
    existingConfig.set("extensions", extensions);
    logger_1.logger.info("Adding Extensions to " + clc.bold("firebase.json") + "...");
    existingConfig.writeProjectFile("firebase.json", existingConfig.src);
}
async function writeEnvFile(spec, existingConfig, force) {
    const content = Object.entries(spec.params)
        .map((r) => `${r[0]}=${r[1]}`)
        .join("\n");
    await existingConfig.askWriteProjectFile(`extensions/${spec.instanceId}.env`, content, force);
}
async function writeFiles(have, options) {
    const existingConfig = config_1.Config.load(options, true);
    if (!existingConfig) {
        throw new error_1.FirebaseError("Not currently in a Firebase directory. Please run `firebase init` to create a Firebase directory.");
    }
    if (existingConfig.has("extensions") &&
        Object.keys(existingConfig.get("extensions")).length &&
        !options.nonInteractive &&
        !options.force) {
        const currentExtensions = Object.entries(existingConfig.get("extensions"))
            .map((i) => `${i[0]}: ${i[1]}`)
            .join("\n\t");
        const overwrite = await prompt_1.promptOnce({
            type: "list",
            message: `firebase.json already contains extensions:\n${currentExtensions}\nWould you like to overwrite or merge?`,
            choices: [
                { name: "Overwrite", value: true },
                { name: "Merge", value: false },
            ],
        });
        if (overwrite) {
            existingConfig.set("extensions", {});
        }
    }
    writeExtensionsToFirebaseJson(have, existingConfig);
    for (const spec of have) {
        await writeEnvFile(spec, existingConfig, options.force);
    }
}
exports.writeFiles = writeFiles;
