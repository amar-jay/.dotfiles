"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Delegate = exports.tryCreateDelegate = exports.FUNCTIONS_RUNTIME = exports.FUNCTIONS_CODEGEN = exports.FUNCTIONS_SDK = exports.ADMIN_SDK = void 0;
const util_1 = require("util");
const node_fetch_1 = require("node-fetch");
const fs = require("fs");
const path = require("path");
const portfinder = require("portfinder");
const spawn = require("cross-spawn");
const error_1 = require("../../../../error");
const logger_1 = require("../../../../logger");
const discovery = require("../discovery");
const projectUtils_1 = require("../../../../projectUtils");
const gomod = require("./gomod");
const VERSION_TO_RUNTIME = {
    "1.13": "go113",
};
exports.ADMIN_SDK = "firebase.google.com/go/v4";
exports.FUNCTIONS_SDK = "github.com/FirebaseExtended/firebase-functions-go";
exports.FUNCTIONS_CODEGEN = exports.FUNCTIONS_SDK + "/support/codegen";
exports.FUNCTIONS_RUNTIME = exports.FUNCTIONS_SDK + "/support/runtime";
async function tryCreateDelegate(context, options) {
    const relativeSourceDir = options.config.get("functions.source");
    const sourceDir = options.config.path(relativeSourceDir);
    const goModPath = path.join(sourceDir, "go.mod");
    const projectId = projectUtils_1.needProjectId(options);
    let module;
    try {
        const modBuffer = await util_1.promisify(fs.readFile)(goModPath);
        module = gomod.parseModule(modBuffer.toString("utf8"));
    }
    catch (err) {
        logger_1.logger.debug("Customer code is not Golang code (or they aren't using gomod)");
        return;
    }
    let runtime = options.config.get("functions.runtime");
    if (!runtime) {
        if (!module.version) {
            throw new error_1.FirebaseError("Could not detect Golang version from go.mod");
        }
        if (!VERSION_TO_RUNTIME[module.version]) {
            throw new error_1.FirebaseError(`go.mod specifies Golang version ${module.version} which is unsupported by Google Cloud Functions. Valid values are ${Object.keys(VERSION_TO_RUNTIME).join(", ")}`);
        }
        runtime = VERSION_TO_RUNTIME[module.version];
    }
    return new Delegate(projectId, sourceDir, runtime, module);
}
exports.tryCreateDelegate = tryCreateDelegate;
class Delegate {
    constructor(projectId, sourceDir, runtime, module) {
        this.projectId = projectId;
        this.sourceDir = sourceDir;
        this.runtime = runtime;
        this.module = module;
        this.name = "golang";
    }
    validate() {
        return Promise.resolve();
    }
    async build() {
        try {
            await util_1.promisify(fs.mkdir)(path.join(this.sourceDir, "autogen"));
        }
        catch (err) {
            if ((err === null || err === void 0 ? void 0 : err.code) !== "EEXIST") {
                throw new error_1.FirebaseError("Failed to create codegen directory", { children: [err] });
            }
        }
        const genBinary = spawn.sync("go", ["run", exports.FUNCTIONS_CODEGEN, this.module.module], {
            cwd: this.sourceDir,
            env: {
                HOME: process.env.HOME,
                PATH: process.env.PATH,
                GOPATH: process.env.GOPATH,
            },
            stdio: ["ignore", "pipe", "pipe"],
        });
        if (genBinary.status != 0) {
            throw new error_1.FirebaseError("Failed to run codegen", {
                children: [new Error(genBinary.stderr.toString())],
            });
        }
        await util_1.promisify(fs.writeFile)(path.join(this.sourceDir, "autogen", "main.go"), genBinary.stdout);
    }
    watch() {
        return Promise.resolve(() => Promise.resolve());
    }
    serve(port, adminPort, envs) {
        const childProcess = spawn("go", ["run", "./autogen"], {
            env: Object.assign(Object.assign({}, envs), { PORT: port.toString(), ADMIN_PORT: adminPort.toString(), HOME: process.env.HOME, PATH: process.env.PATH, GOPATH: process.env.GOPATH }),
            cwd: this.sourceDir,
            stdio: ["ignore", "pipe", "inherit"],
        });
        childProcess.stdout.on("data", (chunk) => {
            logger_1.logger.debug(chunk.toString());
        });
        return Promise.resolve(async () => {
            const p = new Promise((resolve, reject) => {
                childProcess.once("exit", resolve);
                childProcess.once("error", reject);
            });
            await node_fetch_1.default(`http://localhost:${adminPort}/quitquitquit`);
            setTimeout(() => {
                if (!childProcess.killed) {
                    childProcess.kill("SIGKILL");
                }
            }, 10000);
            return p;
        });
    }
    async discoverSpec(configValues, envs) {
        let discovered = await discovery.detectFromYaml(this.sourceDir, this.projectId, this.runtime);
        if (!discovered) {
            const getPort = util_1.promisify(portfinder.getPort);
            const port = await getPort();
            portfinder.basePort = port + 1;
            const adminPort = await getPort();
            const kill = await this.serve(port, adminPort, envs);
            try {
                discovered = await discovery.detectFromPort(adminPort, this.projectId, this.runtime);
            }
            finally {
                await kill();
            }
        }
        discovered.environmentVariables = envs;
        return discovered;
    }
}
exports.Delegate = Delegate;
