'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var events = require('events');
var fs = _interopDefault(require('fs-extra'));
var glob = _interopDefault(require('fast-glob'));

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

class Wares {
  constructor() {
    this.middlewares = [];
  }

  use(middleware) {
    this.middlewares = this.middlewares.concat(middleware);
    return this;
  }

  run(context) {
    return this.middlewares.reduce((current, next) => {
      return current.then(() => Promise.resolve(next(context)));
    }, Promise.resolve());
  }

}

class Majo extends events.EventEmitter {
  constructor() {
    super();
    /**
     * @typedef {(ctx: Majo) => Promise<void> | void} Middleware
     * @type {Middleware[]} */

    this.middlewares = [];
    /**
     * An object you can use across middleware to share states
     * @type {{[k: string]: any}}
     */

    this.meta = {};
  }
  /**
   * Find files from specific directory
   * @param {string | string[]} source Glob patterns
   * @param {{baseDir?: string, dotFiles?: boolean}} opts
   * @param opts.baseDir The base directory to find files
   * @param opts.dotFiles Including dot files
   */


  source(patterns, {
    baseDir = '.',
    dotFiles = true
  } = {}) {
    this.baseDir = path.resolve(baseDir);
    this.sourcePatterns = patterns;
    this.dotFiles = dotFiles;
    return this;
  }
  /**
   * Use a middleware
   * @param {(ctx: Majo) => Promise<void> | void} middleware
   */


  use(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
  /**
   * Process middlewares against files
   */


  process() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const allStats = yield glob(_this.sourcePatterns, {
        cwd: _this.baseDir,
        dot: _this.dotFiles,
        stats: true
      });
      /**
       * @typedef {{path: string, stats: fs.Stats, contents: Buffer}} File
       * @type {{[relativePath: string]: File}}
       */

      _this.files = {};
      yield Promise.all(allStats.map(stats => {
        const absolutePath = path.resolve(_this.baseDir, stats.path);
        return fs.readFile(absolutePath).then(contents => {
          const file = {
            contents,
            stats,
            path: absolutePath
          };
          _this.files[stats.path] = file;
        });
      }));
      yield new Wares().use(_this.middlewares).run(_this);
      return _this;
    })();
  }
  /**
   * Filter files
   * @param {(relativePath: string, file: File) => boolean} fn Filter handler
   */


  filter(fn) {
    return this.use(context => {
      for (const relativePath in context.files) {
        if (!fn(relativePath, context.files[relativePath])) {
          delete context.files[relativePath];
        }
      }
    });
  }
  /**
   * Transform file at given path
   * @param {string} relativePath Relative path
   * @param {(contents: string) => string} fn Transform handler
   */


  transform(relativePath, fn) {
    const contents = this.files[relativePath].contents.toString();
    const result = fn(contents);

    if (!result.then) {
      this.files[relativePath].contents = Buffer.from(result);
      return;
    }

    return result.then(newContents => {
      this.files[relativePath].contents = Buffer.from(newContents);
    });
  }
  /**
   * Run middlewares and write processed files to disk
   * @param {string} dest Target directory
   * @param {{baseDir?: string, clean?: boolean}} opts
   * @param opts.baseDir Base directory to resolve target directory
   * @param opts.clean Clean directory before writing
   */


  dest(dest, {
    baseDir = '.',
    clean = false
  } = {}) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const destPath = path.resolve(baseDir, dest);
      yield _this2.process();

      if (clean) {
        yield fs.remove(destPath);
      }

      yield Promise.all(Object.keys(_this2.files).map(filename => {
        const contents = _this2.files[filename].contents;
        const target = path.join(destPath, filename);

        _this2.emit('write', filename, target);

        return fs.ensureDir(path.dirname(target)).then(() => fs.writeFile(target, contents));
      }));
      return _this2;
    })();
  }
  /**
   * Get file contents as a UTF-8 string
   * @param {string} relativePath Relative path
   * @return {string}
   */


  fileContents(relativePath) {
    return this.file(relativePath).contents.toString();
  }
  /**
   * Write contents to specific file
   * @param {string} relativePath Relative path
   * @param {string} string File content as a UTF-8 string
   */


  writeContents(relativePath, string) {
    this.files[relativePath].contents = Buffer.from(string);
    return this;
  }
  /**
   * Get the fs.Stats object of specified file
   * @param {string} relativePath Relative path
   * @return {fs.Stats}
   */


  fileStats(relativePath) {
    return this.file(relativePath).stats;
  }
  /**
   * Get a file by relativePath path
   * @param {string} relativePath Relative path
   * @return {File}
   */


  file(relativePath) {
    return this.files[relativePath];
  }
  /**
   * Delete a file
   * @param {string} relativePath Relative path
   */


  deleteFile(relativePath) {
    delete this.files[relativePath];
    return this;
  }
  /**
   * Create a new file
   * @param {string} relativePath Relative path
   * @param {File} file
   */


  createFile(relativePath, file) {
    this.files[relativePath] = file;
    return this;
  }
  /**
   * Get an array of sorted file paths
   * @return {string[]}
   */


  get fileList() {
    return Object.keys(this.files).sort();
  }

}

const majo = () => new Majo();

majo.glob = glob;
majo.fs = fs;

module.exports = majo;
